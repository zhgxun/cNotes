# Go database/sql 教程

在Go中使用SQL或类SQL数据库的惯用方法是通过database/sql包。 它为面向行的数据库提供了轻量级的接口。 这个网站对最常见的方面如何使用提供一个参考。

为什么需要这样？软件包的文档告诉您所有操作，但它并没有告诉您如何使用这个软件包。我们中的许多人发现自己希望能够快速参考和“入门”的方向来讲述故事而不是列举事实。欢迎捐款(看原意应该是欢迎fork源代码) 请在[这里](https://github.com/VividCortex/go-database-sql-tutorial)提交请求。

##1、概观

在Go中访问数据库，需要使用**sql.DB**类型。您可以使用此类型创建语句和事务，执行查询和获取结果。

您应该知道的第一件事是，一个**sql.DB**不是一个数据库连接。 它也不是对任何一个特定数据库软件的概念如数据库或模式的映射。它是一个接口的抽象和数据库存在，很可能就像本地文件一样多样化，通过网络连接，内存或进程访问。

**sql.DB**在下列场景中执行一些重要任务：

1. 它通过驱动程序打开和关闭与实际底层数据库的连接。

2. 它根据需要管理一个连接池，这可能是下文所提到的各种各样的事情。

**sql.DB**抽象旨在让您不必担心如何管理对底层数据存储的并发访问。当您使用它来执行任务时，连接被标记为可用，然后在不再使用时返回到可用池。一个后果是，如果您无法将连接释放到池中，则可能导致**db.SQL**打开大量连接，可能会耗尽资源（太多连接，打开的文件句柄太多，缺少可用网络端口等）。 我们稍后再讨论一下。

创建sql.DB后，可以使用它来查询它所代表的数据库，以及创建语句和事务。

##2、导入数据库驱动

要使用database/sql，您需要该程序包本身，以及要使用的特定数据库的驱动程序（因为官方提供的包只是提供接口，没有指定任何的具体数据库类型实现）。

您通常不应直接使用该驱动程序包，尽管有些驱动开发者鼓励您这样做（在我们看来，这通常是一个糟糕的想法）。相反，如果可能，您的代码应该仅引用database/sql中定义的类型。这有助于避免使您的代码取决于驱动程序，以便您可以以最小的代码更改来更改底层驱动程序（或您正在使用的数据库）。它也强制你使用Go习语，而不是特定的驱动程序作者可能提供的特殊习语。

在本文档中，我们将使用@julienschmidt和@arnehormann实现的优秀[MySQL](https://github.com/go-sql-driver/mysql)驱动程序作为例子。

将以下内容添加到Go源文件的顶部：

```go
import (
    "database/sql"
    _ "github.com/go-sql-driver/mysql"
)
```

请注意，我们将匿名加载驱动程序，将其限定符别名为_（仅初始化包），因此我们的代码中没有一个导出的名称可见。 在引擎下，驱动程序将其自身注册为可用的database/sql包，但通常没有其他情况发生。

现在，您已准备好访问数据库。

##3、访问数据库

现在您已经加载了驱动程序包，就可以创建一个数据库对象 **sql.DB**。

要创建一个**sql.DB**，使用 **sql.Open()**。 这返回一个 ***sql.DB**：

```go
func main() {
    db, err := sql.Open("mysql", "user:password@tcp(127.0.0.1:3306)/hello")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
}
```

在示例中，我们说明了几件事情：

1. **sql.Open()**的第一个参数是驱动程序名称。 这是驱动程序用于向database/sql注册的字符串，并且通常与包名称相同以避免混淆。 例如，它是github.com/go-sql-driver/mysql的mysql。 某些驱动程序不符合惯例并使用数据库名称，例如 github.com/mattn/go-sqlite3的sqlite3和github.com/lib/pq的postgres。

2. 第二个参数是一个特定于驱动程序的语法，它告诉驱动程序如何访问底层数据存储。 在这个例子中，我们连接到本地MySQL服务器实例中的“hello”数据库。

3. 你应该（几乎）总是检查并处理从所有database/sql操作返回的错误。 有一些特殊情况，我们稍后将讨论这样做是没有意义的。

4. 如果**sql.DB**没有超出该函数的生命周期在作用域范围内，则 **defer db.Close()**是惯用的。

也许反直觉地，**sql.Open()**不建立与数据库的任何连接，也不会验证驱动程序连接参数。相反，它只是准备数据库抽象以供以后使用。首次实际连接到底层数据存储区将在第一次需要时懒惰地建立。如果要立即检查数据库是否可用（例如，检查是否可以建立网络连接并登录），请使用**db.Ping()**来执行此操作，并记住检查错误：

```go
err = db.Ping()
if err != nil {
    // do something here
}
```

尽管在完成数据库之后**Close()**数据库是惯用的，但是**sql.DB**对象被设计为常驻内存（等）的。不要经常**Open()**和**Close()**数据库。相反，为您需要访问的每个不同的数据存储创建一个**sql.DB**对象，并保留它，直到程序完成访问该数据存储。根据需要传递，或使其在全局范围内可用，但保持开放。并且不要从临时的函数中**Open()**和**Close()**它。相反，将**sql.DB**作为参数传递给该临时函数。

如果您不将**sql.DB**视为长期存在的对象，则可能会遇到诸如重复使用和连接共享不足，可用网络资源耗尽以及由于TIME_WAIT中剩余的大量TCP连接而导致的零星故障的问题状态。 这样的问题是您没有像设计的那样使用database/sql的迹象。

现在是时候使用你的sql.DB对象了。

##4、检索结果集

有几个惯用的操作来从数据存储中检索结果。

1. 执行返回行的查询。
2. 准备重复使用的语句，执行多次，并将其销毁。
3. 以一次性方式执行声明，而无需重复使用。
4. 执行返回一行的查询。 这个特殊情况有一个特殊的情形。

Go的 database/sql 函数名称很重要。如果一个函数名称包含**Query**，它被设计为询问数据库的问题，并返回一组行，即使它是空的。 不返回行的语句不应使用**Query**函数; 他们应该使用**Exec()**。

###4.1 从数据库获取数据

让我们来看一下如何查询数据库，使用结果的例子。 我们将向用户表查询ID为1的用户，并打印出用户的ID和名称。 我们将使用**rows.Scan()**将结果分配给变量，一次一行。

```go
var (
	id   int
	name string
)
rows, err := db.Query("select id, name from users where id = ?", 1)
if err != nil {
	log.Fatal(err)
}
defer rows.Close()
for rows.Next() {
	err := rows.Scan(&id, &name)
	if err != nil {
		log.Fatal(err)
	}
	log.Println(id, name)
}
err = rows.Err()
if err != nil {
	log.Fatal(err)
}
```

以上代码中发生了什么：

1. 我们使用**db.Query()**将查询发送到数据库。 我们像往常一样检查错误。
2. 我们**rows.Close()**。 这个非常重要。
3. 我们用**rows.Next()**迭代行。
4. 我们用**rows.Scan()**读取每行中的列变量。
5. 我们完成遍历行后我们检查错误。

这几乎是Go中唯一的办法。 例如，你不能得到一行作为map。 这是因为一切都是强类型的。 您需要创建正确类型的变量并将指针传递给它们，正如上面所看到的。

其中的几个部分容易出错，可能会产生不良后果。

* 您应该始终检查**for rows.Next()**循环结尾处的错误。 如果循环中出现错误，则需要了解它。 不要仅仅假定循环遍历，直到你已经处理了所有的行。

* 第二，只要有一个打开的结果集（由行代表），底层连接就是忙，不能用于任何其他查询。 这意味着它在连接池中不可用。 如果您使用**rows.Next()**迭代所有行，最终将读取最后一行，**rows.Next()**将遇到内部EOF错误，并为您调用**rows.Close()**。 但是，如果由于某种原因退出该循环 - 早期返回等等，那么行不会关闭，并且连接保持打开状态。 （如果**rows.Next()**由于错误而返回false，则会自动关闭）。 这是一种耗尽资源的简单方法。

* **rows.Close()**是一个无害的无操作，如果它已经关闭，所以你可以多次调用它。 但是请注意，我们首先检查错误，如果没有错误，则只调用**rows.Close()**，以避免运行时的紧急情况。

* 你应该总是**defer rows.Close()**，即使你也在循环结束时调用**rows.Close()**，这不是一个坏主意。

* 不要在循环中推迟。 延迟语句在函数退出之前不会执行，所以长时间运行的函数不应该使用它。 如果你这样做，你会慢慢积累记忆。 如果您在循环中反复查询和使用结果集，则在完成每个结果后应显式调用**rows.Close()**，而不使用延迟。

###4.2 Scan()如何工作

当您迭代行并将其扫描到目标变量中时，Go会在幕后为您执行数据类型转换。 它基于目标变量的类型。 意识到这可以清理您的代码，并帮助避免重复工作。

例如，假设您从使用字符串列定义的表中选择一些行，例如**VARCHAR(45)**或类似的列。 然而，您恰好知道表格总是包含数字。 如果将指针传递给字符串，Go会将字节复制到字符串中。 现在可以使用**strconv.ParseInt()**或类似的方式将值转换为数字。 您必须检查SQL操作中的错误以及解析整数的错误。 这是杂乱而乏味的。

或者，您只需将**Scan()**指针指向一个整数即可。 Go会检测到并为您调用**strconv.ParseInt()**。 如果转换出现错误，则调用**Scan()**将返回。 你的代码现在越来越小了。 这是推荐使用database/sql的方法。

###4.3 准备查询

一般来说，你应该总是准备多次使用查询。 准备查询的结果是一个准备语句，可以为执行语句时提供的参数提供占位符（a.k.a. bind值）。 这比连接字符串要好得多，因为所有通常的原因（例如避免SQL注入攻击）。

在MySQL中，参数占位符为？，在PostgreSQL中为$ N，其中N为数字。 SQLite接受这两者之一。 在Oracle占位符中以冒号开始，并命名为：param1。 我们会用?因为我们以MySQL为例。

```go
stmt, err := db.Prepare("select id, name from users where id = ?")
if err != nil {
	log.Fatal(err)
}
defer stmt.Close()
rows, err := stmt.Query(1)
if err != nil {
	log.Fatal(err)
}
defer rows.Close()
for rows.Next() {
	// ...
}
if err = rows.Err(); err != nil {
	log.Fatal(err)
}
```

在引擎下，**db.Query()**实际上准备，执行和关闭一个准备好的语句。 这是数据库的三次往返。 如果您不小心，您的应用程序可以将数据库交互的数量增加三倍！ 某些驱动程序可以在特定情况下避免这种情况，但并不是所有驱动程序都可以。 查看准备的声明更多。

