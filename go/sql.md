# Go database/sql 教程

在Go中使用SQL或类SQL数据库的惯用方法是通过database/sql包。 它为面向行的数据库提供了轻量级的接口。 这个网站对最常见的方面如何使用提供一个参考。

为什么需要这样？软件包的文档告诉您所有操作，但它并没有告诉您如何使用软件包。我们中的许多人发现自己希望能够快速参考和“入门”的方向来讲述故事而不是列举事实。欢迎捐款 请在[这里](https://github.com/VividCortex/go-database-sql-tutorial)发送拉请求。

##概观

在Go中访问数据库，您需要使用sql.DB类型。您可以使用此类型创建语句和事务，执行查询和获取结果。

您应该知道的第一件事是，一个sql.DB不是一个数据库连接。 它也不是对任何一个特定数据库软件的概念如数据库或模式的映射。它是一个接口的抽象和数据库存在，很可能就像本地文件一样多样化，通过网络连接，内存或进程访问。

sql.DB在下列场景中执行一些重要任务：
它通过驱动程序打开和关闭与实际底层数据库的连接。
它根据需要管理一个连接池，这可能是所提到的各种各样的事情。

sql.DB抽象旨在让您不必担心如何管理对底层数据存储的并发访问。当您使用它来执行任务时，连接被标记为可用，然后在不再使用时返回到可用池。一个后果是，如果您无法将连接释放到池中，则可能导致db.SQL打开大量连接，可能会耗尽资源（太多连接，打开的文件句柄太多，缺少可用网络端口等）。 我们稍后再讨论一下。

创建sql.DB后，可以使用它来查询它所代表的数据库，以及创建语句和事务。

##导入数据库驱动

要使用database/sql，您需要该程序包本身，以及要使用的特定数据库的驱动程序。

您通常不应直接使用该驱动程序包，尽管有些驱动开发者鼓励您这样做（在我们看来，这通常是一个糟糕的想法）。相反，如果可能，您的代码应该仅引用database/sql中定义的类型。这有助于避免使您的代码取决于驱动程序，以便您可以以最小的代码更改来更改底层驱动程序（或您正在使用的数据库）。它也强制你使用Go习语，而不是特定的驱动程序作者可能提供的特殊习语。

在本文档中，我们将使用@julienschmidt和@arnehormann实现的优秀[MySQL](https://github.com/go-sql-driver/mysql)驱动程序作为例子。

将以下内容添加到Go源文件的顶部：

```go
import (
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
)
```

请注意，我们将匿名加载驱动程序，将其限定符别名为_，因此我们的代码中没有一个导出的名称可见。 在引擎下，驱动程序将其自身注册为可用的database/sql包，但通常没有其他情况发生。

现在，您已准备好访问数据库。

##访问数据库

现在您已经加载了驱动程序包，就可以创建一个数据库对象sql.DB。

要创建一个sql.DB，使用sql.Open()。 这返回一个*sql.DB：

```go
func main() {
	db, err := sql.Open("mysql", "user:password@tcp(127.0.0.1:3306)/hello")
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()
}
```

在示例中，我们说明了几件事情：

sql.Open的第一个参数是驱动程序名称。 这是驱动程序用于向database/sql注册的字符串，并且通常与包名称相同以避免混淆。 例如，它是github.com/go-sql-driver/mysql的mysql。 某些驱动程序不符合惯例并使用数据库名称，例如 github.com/mattn/go-sqlite3的sqlite3和github.com/lib/pq的postgres。

第二个参数是一个特定于驱动程序的语法，它告诉驱动程序如何访问基础数据存储。 在这个例子中，我们连接到本地MySQL服务器实例中的“hello”数据库。

你应该（几乎）总是检查并处理从所有database/sql操作返回的错误。 有一些特殊情况，我们稍后将讨论这样做是没有意义的。

如果sql.DB没有超出该函数的生命周期在作用域范围内，则 defer db.Close()是惯用的。

也许反直觉地，sql.Open()不建立与数据库的任何连接，也不会验证驱动程序连接参数。相反，它只是准备数据库抽象以供以后使用。首次实际连接到基础数据存储区将在第一次需要时懒惰地建立。如果要立即检查数据库是否可用（例如，检查是否可以建立网络连接并登录），请使用db.Ping()来执行此操作，并记住检查错误：

```go
err = db.Ping()
if err != nil {
	// do something here
}
```

尽管在完成数据库之后Close()数据库是惯用的，但是sql.DB对象被设计为长住的。不要经常Open()和Close()数据库。相反，为您需要访问的每个不同的数据存储创建一个sql.DB对象，并保留它，直到程序完成访问该数据存储。根据需要传递，或使其在全局范围内可用，但保持开放。并且不要从临时的函数中Open()和Close()它。相反，将sql.DB作为参数传递给该临时函数。

如果您不将sql.DB视为长期存在的对象，则可能会遇到诸如重复使用和连接共享不足，可用网络资源耗尽以及由于TIME_WAIT中剩余的大量TCP连接而导致的零星故障的问题状态。 这样的问题是您没有像设计的那样使用database/sql的迹象。

现在是时候使用你的sql.DB对象了。
