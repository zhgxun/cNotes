package github.banana.view;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 面试题整理
 * <p>
 * 整理自文章: https://mp.weixin.qq.com/s/P4IgX5ox-XuzZiEI60HoRQ
 * <p>
 * 1. 介绍一下自己, 讲讲项目经历
 * 技术: 主语言是 Java, 借助商业平台已有基础工具来整合
 * 概览: 目前在负责凤巢下商业阿拉丁业务端的开发, 通过接入广告主提供的物料, 以原生广告的形式在搜索列表页按需展示给用户
 * 流程: 主要分为检索端和业务端两个团队共同完成, 我负责业务端的数据接入和转换, 按检索端的要求产出各种数据格式提供给检索建索引和获取广告物料
 * <p>
 * 2. 项目中的微服务是怎么划分的, 划分粒度是
 * 不是特别严格的微服务架构, 其它业务是以微服务的方式接入的, 比如用户中心, 预算上下线, 财务信息, 但是项目内部还是以RPC和数据流工具的方式来解耦和互相通信的
 * 总体上还是以大服务为主, 小服务独立为辅
 * <p>
 * 3. 实践微服务架构中, 有遇到什么问题
 * 服务的稳定性, 比如线下环境, 用户服务不提供服务，导致业务端无法进入系统
 * <p>
 * 线上服务客户关系由其它团队负责, 但是业务端无法对用户状态来更改业务需求
 * 比如上次线上遇到一个大客户, 因上游系统, 上游系统也接了更上游的系统, 用户状态是暂未生效, 找了好几个团队的人，他们也无法修改用户状态,
 * 甚至不知道这个状态是在哪里变更过的, 其实用户状态应该是正常的,
 * 导致下游系统不能依赖这种跟业务不是强一致性的状态, 业务端只能不考虑用户状态, 交给登陆和授权中心去拦截
 * <p>
 * RPC调用, 有时候会不可用, 上下线过程中, 或者服务异常时, 会导致部分数据丢失, 好在有一些数据可以接收一定程度的丢失, 但是对于不可损失的流量, 就相当危险
 * <p>
 * 4. 如何解决微服务数据一致性的问题
 * 目前使用的是消息队列
 * 失败后重试, 下次更新补偿到数据一致性
 * <p>
 * 根据业务的重要性来处理, 比如订单, 主要的订单信息存放在同一个服务中, 保证事务后数据的一致性, 至少不影响用户感官上的信息,
 * 不要因为一个不重要的服务不可用导致下单失败, 但是订单的扩展服务, 比如积分,
 * 计数等就可以暂时不一致, 后续通过重试或者校验机制来保证数据的最终一致性
 * <p>
 * 5. 为什么不用其他MQ, 而选择 Kafka
 * 历史原因, 团队选择, 后人维护, 而且Kafka以类似日志的方式, 速度很快, 团队内部有很好的现成的工具支持使用Kafka, 并且有专人维护, 但是后续据说逐渐的要废弃了
 * <p>
 * 6. 为什么选择 ZK
 * http://www.cnblogs.com/dimmacro/p/4457665.html 参考这篇了解即可, 暂时无法也不可能去深入
 * <p>
 * 7. ZK在选举过程中还能对外提供服务吗
 * <p>
 * 8. 对 Paxos 算法了解多少
 * <p>
 * 9. 如果让你来设计一个春晚抢红包架构, 你会怎么设计
 * <p>
 * 10. 有什么想问我的
 * <p>
 * 11. 怎么解决缓存击穿问题
 * 缓存的数据首先是热点数据, 即是数据访问频路比较高的数据, 而且业务对数据需要读多写少, 否则缓存一直在变, 维护成本很高, 其次是数据一致性要求差
 * 即可容忍暂时的不一致, 但会保证数据的最终一致性
 * <p>
 * 缓存击穿是指访问跳过缓存, 即是缓存中没有目标数据, 流量发送到数据库层, 如果是高并发阶段, 如果处理不当, 很容易拖垮数据库
 * 方案一: 定时刷新
 * 这种对简单的缓存, 即缓存key比较稳定, 缓存的数据粒度比较大很有效, 后台有任务定期去检查, 将快要失效的数据更新
 * 方案二: 检查更新
 * 获取数据时也检查缓存的有效性和有效时间, 在失效之前主动更新缓存, 缺点是如果高并发一下子压上来, 错过了缓存更新的时间, 一样被击穿
 * 方案三: 分级缓存
 * 比如可以把缓存分为两级缓存, L1 和 L2 , L1级缓存不加锁, 并发查询, 但是缓存从 L1 击穿进入 L2层需要控制只有一个线程去访问
 * L2中的缓存不能淘汰, 容忍一段时间的垃圾数据, 同步回 L1 级缓存
 * <p>
 * 以上方案都无法解决缓存中不存在的数据, 还是容易给数据库造成压力
 * <p>
 * 第四种方案: 加锁控制
 * 使用互斥锁来来实现
 * {@link Cache#tryAquireCache()}
 * <p>
 * 12. Redis 数据结构及其使用场景
 * 字符串  普通的键值对存储
 * 哈希    类似字典
 * 列表    类似队列, 压缩列表和双向循环链表
 * 集合    无需集合
 * 有序集合 有序集合, 分值和排序, 散列表和跳表, 散列表其实一种压缩的数组类型
 * <p>
 * 13. Http 长连接和短连接
 * 本质上是TCP的长连接和短连接
 * Http属于应用层协议,
 * TCP属于传输层协议, 主要解决如何在IP层之上可靠地传输数据包, 使得网络上接收端和发送端的数据完整和顺序一致, 是一种可靠的面向连接的协议
 * IP属于网络层协议, 主要解决网络路由和寻址的问题
 * <p>
 * 所谓链接其实就是客户端和服务器的内存里保存一份关于对方的信息, 如ip地址, 端口号等
 * <p>
 * Http/1.0 默认使用短连接, 客户端与服务器没进行一次交互就建立一次连接, 任务结束就中断连接
 * 从Http/1.1 开始默认使用长连接, 用以保持连接的连接性, 响应头中会有一个头信息
 * <pre>Connection: keep-alive</pre>
 * 在使用长连接的情况下, 当一个网页打开完毕后, 客户端和服务器之间用于传输数据的链接不会被关闭, 客户端再次访问这个服务器时, 会继续使用这一条
 * 已经建立的链接, Keep-alive 不会永久保持, 它有一个保持时间, 可以在不同的服务器软件中设定这个时间
 * <p>
 * 三次握手建立一个连接, 四次挥手关闭一个连接
 * https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q 这篇文章让你充分理解 三次握手
 * SYN 用来初始化一个连接的序列号
 * RST 重置连接
 * ACK 确认号
 * FIN 结束向对方发送数据
 * <p>
 * 建立链接的三次握手
 * SYN->SYN+ACK->ACK
 * <p>
 * FIN->ACK->FIN->ACK
 * <p>
 * 14. TCP的十一种状态
 * CLOSED
 * 初始状态, 表示 TCP 连接是关闭着的或者未打开的, 即连接当前是可用的
 * <p>
 * LISTEN
 * 表示服务器端的某个 Socket 处于监听状态, 可接受客户端连接
 * <p>
 * SYN_RCVD
 * 表示服务器端收到了来自客户端请求连接的 SYN 报文, 在正常情况下, 这个状态是服务器端的 Socket 在建立 Tcp 连接时的三次握手会话过程的一个
 * 中间状态, 很短暂, 基本上用 netstat 很难看到这种状态, 除非故意写一些检测程序, 将 TCP 三次握手过程中的最后一个 ACK 报文不予发送
 * 当 tcp 连接处于此状态时, 再收到客户端的 ACK 报文, 它就会进入到 ESTABLISHED 状态, 即连接建立状态
 * <p>
 * SYN_SENT
 * 这个状态与 SYN_RCVD 相呼应, 当客户端 Socket 执行 connect() 进行连接时, 它首先发送 SYN 报文, 然后随即进入 SYN_SENT 状态, 并等待
 * 服务端发送三次握手中的第2个报文, SYN_SENT 状态表示客户端已经发送 SYN 报文
 * <p>
 * ESTABLISHED
 * 表示tcp 连接已经建立
 * <p>
 * FIN_WAIT_1
 * 其实 FIN_WAIT_1 和 FIN_WAIT_2 两种状态的真正含义都是表示等待对方的 FIN 报文, 而这两种状态的区别是
 * FIN_WAIT_1 状态实际上是当 Socket 在 ESTABLISHED 状态时, 它想主动关闭连接, 向对方发送了 FIN 报文, 此时 Socket 进入到 FIN_WAIT_1 状态
 * 而当对方回应 ACK 报文后, 则进入 FIN_WAIT_2 状态
 * 当然在实际情况下, 无论对方处于任何状态下, 都应该马上回应 ACK 报文, 所以 FIN_WAIT_1 状态一般是比较难见到的, 而 FIN_WAIT_2 状态有时
 * 可以用 netstat 看到
 *
 * <p>
 * FIN_WAIT_2
 * 实际上 FIN_WAIT_2 状态下的 Socket 表示半连接, 即有一方调用 close() 主动要求关闭连接, 注意 FIN_WAIT_2 是没有超时的, 这种状态下
 * 如果对方不关闭(不配合完成4次挥手)那这个 FIN_WAIT_2 状态将一直保持到系统重启, 越来越多的 FIN_WAIT_2 将导致内核 crash
 *
 * <p>
 * TIME_WAIT
 * 表示收到了对方的 FIN 报文, 并发送了 ack 报文, time_wait 状态下的 tcp 连接会等待 2 * msl(最大分段生存期, 是指一个 tcp 报文在 internet 上
 * 最长的生存时间, 每个具体的 tcp 协议实现都必须选择一个确定的 msl 值, RFC 1122 建议是2分钟,  但具体的实现有差异), 然后即可回到 CLOSED
 * 可用状态了
 *
 * <p>
 * CLOSING
 * 比较少见
 *
 * <p>
 * CLOSE_WAIT
 * 等待关闭,
 *
 * <p>
 * LAST_ACK
 * 当被动关闭的一方在发送 fin 报文后, 就处于 last_ack 状态, 当收到对方的 ack 报文后, 也就可以进入 closed 状态等待下次连接了
 * <p>
 * 15. 评价一下自己
 * 生活中还是比较乐观, 周末爱出去旅游, 平时喜欢接触一些新东西, 喜欢新的技术, 愿意接受挑战
 * <p>
 * 16. 数据库高可用架构
 * 主从复制, 一主多从或者多主多从均可
 * 访问入口其实只有一个, 在百度内部叫 百度名字服务, 不直接指向具体的ip, 而是指向一个中间代理层, 通过代理层去寻找真实的机器
 * MyCAT 也有类似的功能
 * <p>
 * 17. 数据库主从一致性问题
 * 半同步复制 - 我们主要的选择, 不是太前端的业务, 允许接受一定的延迟
 * 数据库中间件 - 成本高
 * 缓存记录写key法 - 操作多了一层 cache 层
 * <p>
 * 18. 有什么要问我的
 * 目前项目的情况, 做业务, 做工具, 还是有什么做什么, 是否有架构方面的提升或者参与编写中间件的机会
 * 团队目前的构成情况, 预估自己在团队中属于哪个位置, 如果位置太低, 还没关系可以学习, 但是如果位置太高, 可能需要留意团队发展情况
 * 项目中遇到比较麻烦的问题是哪方面的?人不够开发不完, 还是中间件没抽象, 很多业务是重复的
 * 后续项目中是否有考虑使用新技术进行升级改进等
 * 福利待遇一年是否会有改善
 */
public class FirstTest {

    public static void main(String[] args) {

    }
}

/**
 * 缓存击穿的解决方案, 比较合理也是比较规范的方案
 * 就是加类似自旋的锁
 */
class Cache {

    // 互斥锁
    private static Lock lock = new ReentrantLock();

    /**
     * 假定为缓存获取入口
     *
     * @return 缓存内容
     */
    private String getCacheData() {
        return "Cache";
    }

    /**
     * 保存数据到缓存中
     *
     * @param s 待缓存的数据
     */
    private void setCacheData(String s) {

    }

    /**
     * 从db中获取数据
     *
     * @return 数据内容
     */
    private String getDbData() {
        return "Db";
    }

    /**
     * 加锁方式获取缓存数据, 不适用重量级锁, 会阻塞线程等待, 缓存生效其实优化后很快, 只需要轻量级多自旋等待一定的时间即可
     *
     * @return 缓存数据
     */
    String tryAquireCache() {
        // 统一从缓存中获取
        String data = getCacheData();
        // 缓存失效
        if (data.equals("")) {
            // 第一个线程尝试获取锁
            if (lock.tryLock()) {
                try {
                    // 只能从数据库中获取数据, 期间会阻塞线程访问, 数据库和业务处理性能很重要
                    String t = getDbData();
                    setCacheData(t);
                } finally {
                    // 完毕后释放锁, 此时缓存一定有存在数据, 不担心数据库压力
                    lock.unlock();
                }
            } else {
                // 未获取锁, 说明锁被其它线程占用, 等待缓存中数据即可
                // 尝试从缓存中获取数据, 这里应该有一个等待时间, 可以使用类似自旋锁的方式, 也可以直接等待一定的时间,
                // 结合用户容忍度和用户体验来合理设置即可, 或者用超时时间也可以
                // ...
                data = getCacheData();
            }
        }
        // 除了处理超时外, 都能正确从缓存中获取数据
        return data;
    }
}
