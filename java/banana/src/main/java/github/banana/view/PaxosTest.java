package github.banana.view;

/**
 * Paxos 是用于解决分布式系统中一致性的共识算法, 最基本的功能是为了在多个进程之间对某个值达成一致, 通过这个最基本的功能就可以在多个进程之间
 * 进行数据库, 状态机等对象的同步
 * <p>
 * 基本概念
 * ID 相互不冲突的提案编号, 用于区分不同轮次的提案
 * Value 提案的值, 即最后试图达成共识的候选结果
 * Proposer 提案发起者, 用于提出议案, 提案的内容为 x=value 对同一轮提案, 最多提议一个 value
 * Acceptor 提案投票者, 有多个, Proposer 提出的 x=value 提案必须获得超过半数的 Acceptor 接受后才能被选择, Acceptor 之间完全对等, 在
 * 独立的时间进行提案投票
 * Learner 提案学习者, 一个提案超过半数 Acceptor 通过即可被选择, 其它未确定的 Acceptor 可以通过 Learner 来同步结果
 * <p>
 * 协议流程
 * Prepare 阶段
 * Proposer 选择一个提案编号 n, 向所有的 Acceptor 广播请求
 * Acceptor 接收到 Prepare 请求, 若提案编号比之前接收到的编号都要大, 则承诺将其记录下来, 将不会再接收比该编号小的提议
 * <p>
 * Proposer 阶段
 * Proposer 接收到 Acceptor 的承诺, 如果未超过半数 Acceptor 回复承诺则本次提案失败
 * 如果超过半数
 * 但所有的 Acceptor 都未接收到提案的值 value 则向所有的 Acceptor 发起提案, 内容为自己的提案编号和值
 * 如果有部分 Acceptor 接收过 value 那么从接受过 value 中选择最大的 value 作为本次提案的 value 提议编号保持为 n 此时 Acceptor 不能再发送自己的
 * 提案编号和值, 只能信任接收到的值
 * <p>
 * Acceptor 接收到提议后, 如果该提案编号不等于自身当前承诺的编号, 第一阶段记录的, 不接受该请求, 相等则将提案的 value 写入本地
 *
 * 传统上在非分布式环境中, 我们往往用事务来维护系统的一致性
 * 而Lock机制是最常用的一种控制数据有序修改的手段, 因此, 数据的修改可以分为两个阶段
 * 加锁阶段(多个Proposer根据在单个Acceptor️收到加锁请求的时间先后顺序占用锁, 此时系统有全局时钟)
 * 修改阶段(并释放锁)
 * 在Paxos中, Prepare阶段可以理解为Proposer向Acceptors集合请求加锁阶段, Propose阶段相当于修改阶段, 以这样的角度看, 就不会对为什么Paxos设计成两阶段协议有太多疑惑了
 *
 * 但对于分布式系统而言, 除了缺乏全局时钟外, 还有容错问题: 修改者与资源都会有多个副本, 并且都有可能失效
 *
 * 对于Paxos而言, 则表现为:
 * 1. Acceptor有多个, 因此Paxos要求提案获得大多数Acceptor的Promise, 才算加锁成功
 * 这也比较好理解, 如果小于半数, 则可能存在两个提案同时加锁的情况
 * 2. 每个Proposer都有可能失效, 不能影响其他Proposer工作
 * 传统的独占锁在获得锁定权的Proposer失效时会导致系统死锁, 因此不符合要求, Paxos选择将独占锁改成抢占锁机制, 这意味着需要引入某种可以全局有效的抢占机制
 *
 * 为了全局性的对提案进行排序, Paxos引入提案编号概念, 编号由每个Proposer本地产生并且递增, 具有全局唯一性并且可比较排序
 * Paxos规定高编号的提案可以抢占编号低的提案的锁(反过来也行, 但总需要一个排序规则)
 * 使得低编号提案加锁失败(无法完成大多数Acceptor的提案确认), 这样就不会出现某个Proposer的失效导致的死锁情况的发生
 * (为什么要抢占?因为Proposer之间是孤立的, 而且你永远不知道某个Proposer会在何时失效)
 * 如何理解提案编号的概念?相当于Paxos人为的为分布式系统设定了一个非集中式的全局时钟, 所有的Acceptor进程均认可这种事先安排的顺序对提案的抢占锁进行处理
 * 即然是时钟, 前面发生的提案就不能跑到后面来处理
 * 这个时钟在不同Acceptor之间并不精确同步, 只能保证每个Acceptor节点以一种有序的方式处理Proposer对锁的抢占, 保证每个Accepor上每个提案不
 * 受低编号的影响, 而只受高编号的影响, 以最快的在Acceptor集合内达成提案的收敛
 * 从Proposer角度看, 所有编号的提案, 都在快马加鞭的试图尽快的加锁(prepare)并获得大多数Acceptors的确认(accept)
 * 以免被更高ID的提案给抢占
 * Proposer之间没有任何协调机制, 只能通过Acceptors完成有限交流(低编号提案value向高编号提案的传播)由于每个Paxos过程会以各种组合交叉在一起
 * 局面会比较复杂, 我们抽丝剥茧后, 可以确定的是, 只会有一个提案的value会最终会被加锁并被大多数Acceptors确认
 *
 * 原因如下: 首先, 从Acceptors集合角度来看, 任何时候他们只能承诺最多一个提案, 因为每个Acceptor同时只能承诺一个提案, 任何时刻其承诺某一
 * 个提案的大多数的集合必然只有一个, 成功的加锁是成功的确认的基础, 同时拒绝了更小编号的提案成功确认的可能性, 降低了来自低编号提案的不确定性
 * Proposer需要在成功的加锁之后, 在更大编号的提案抢占锁之前, 完成大多数Acceptor的确认
 * 一旦该编号n的提案加锁并经过大多数Acceptor确认成功后, 更大编号的提案如果能抢占锁成功, 则必然能够学习到编号n提案的value,
 * 因为大多数集合之间必然有交集, 如果更大编号的提案没有抢占锁成功, 则不会给Acceptors集合增加任何新的可供选择的value, 编号n的提案的值
 * 仍然是编号最大的值, 更大编号的提案学习到编号n的提案后, 做为自己的提案内容
 * 依次迭代, 后续提案也是如此, 必然达成一致
 * 因此, 我们需要做的就是等待某个提案的value(可能是一次确认, 也可能是逐渐收敛)成功获得大多数Acceptors确认而胜出
 * 那么, 会不会有可能永远无法有提案胜出呢?有可能, 比如提案轮流抢占锁, 但都在Propose前被下一个提案抢占,
 * 就永远无法有提案胜出了(活锁), 解决方法就是: 随机等待, 重新发起提案
 * (类似的活锁情况还有很多种, 例如: 不同提案之间永远在相同的Acceptors之间争夺承诺但都无法及时写入value
 * 或者每次一个Acceptor确认一个value后就被隔离分区, 后续提案再也接触不到, 到达一半后, 系统再也无法达成大多数
 * 但只要某个分区能够有大多数Acceptor存在, 都可以达成一致
 * 因此, 只要有足够的时间让一个提案获得大多数Acceptors确认就不会有一致性问题
 */
public class PaxosTest {

    public static void main(String[] args) {

    }
}
